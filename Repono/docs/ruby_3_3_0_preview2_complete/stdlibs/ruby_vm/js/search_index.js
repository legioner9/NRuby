var search_data = {"index":{"searchIndex":["rubyvm","rjit","assembler","label","modrm","rel32","block","branchstub","branchtarget","byteptr","cpointer","bitfield","bool","immediate","pointer","struct","union","ctype","bitfield","bool","immediate","pointer","struct","union","codeblock","compiler","context","dwordptr","entrystub","exitcompiler","insncompiler","invariants","jitstate","operandmatcher","type","typediff","*()","*()","*()","*()","+()","+()","+()","-()","-()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","add()","add_block()","and()","assemble()","assert()","assert()","assert()","assert_compatible()","assert_equal()","assume_bop_not_redefined()","assume_method_basic_definition()","assume_method_lookup_stable()","assume_stable_constant_names()","at_current_insn?()","block()","bold()","branch_stub_hit()","build_calling()","builtin_function()","c_method_tracing_currently_enabled?()","call()","clear_local_types()","cmove()","cmovg()","cmovge()","cmovl()","cmovle()","cmovne()","cmovnz()","cmovz()","cmp()","colorize()","comment()","compile()","compile_block()","compile_branch_stub()","compile_entry_chain_guard()","compile_entry_exit()","compile_entry_stub()","compile_full_cfunc_return()","compile_leave_exit()","compile_prologue()","compile_side_exit()","count_insn_exit()","counted_exit()","decode_insn()","def_iseq_ptr()","defer_compilation()","define()","define()","define()","define()","define()","dest_addr()","diff()","dump_disasm()","dump_trace_exits()","dup()","dynamic_symbol?()","encode_mod_rm()","ensure_block_entry_exit()","entry_stub_hit()","ep_at_level()","exit_traces()","extended_reg?()","find()","find_block()","fixnum?()","fixnum?()","flonum?()","flonum?()","format_number()","from()","full_cfunc_return()","get_local_type()","get_opnd_mapping()","get_opnd_type()","guard_block_arg()","handle_opt_send_shift_stack()","imm32()","imm32?()","imm64()","imm64?()","imm8()","imm8?()","imm_bytes()","include?()","incr_counter()","incr_counter()","initialize()","insn()","insn()","invalidate_all()","invalidate_block()","invalidate_blocks()","iseq_lineno()","iseq_lineno()","jbe()","je()","jit_array_len()","jit_array_ptr()","jit_call_alias()","jit_call_attrset()","jit_call_bmethod()","jit_call_cfunc()","jit_call_general()","jit_call_iseq()","jit_call_ivar()","jit_call_method()","jit_call_method_each_type()","jit_call_opt_call()","jit_call_opt_send()","jit_call_opt_struct_aref()","jit_call_optimized()","jit_call_symbol()","jit_caller_setup_arg()","jit_direct_jump()","jit_get_ep()","jit_get_lep()","jit_getivar()","jit_leaf_builtin_func()","jit_protected_callee_ancestry_guard()","jit_push_frame()","jit_search_method()","jit_write_iv()","jl()","jmp()","jne()","jnz()","jo()","jz()","lea()","leave_exit()","limit_block_versions()","list_blocks()","mov()","move_rest_args_to_stack()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_label()","on_cme_invalidate()","on_constant_ic_update()","on_constant_state_changed()","on_tracing_invalidate_all()","on_update_references()","operand()","or()","parse()","pc_to_insn()","peek_at_block_handler()","peek_at_local()","peek_at_self()","peek_at_stack()","pop()","pos_marker()","print_counters()","print_exit_counts()","print_stats()","push()","push_splat_args()","r32?()","r64?()","record_global_inval_patch()","reg_code()","reg_code_extended()","rel32()","remove_block()","resolve_labels()","resolve_rel32()","ret()","rjit_blocks()","runtime_stats()","sar()","save_pc_and_sp()","set_code_addrs()","set_local_type()","set_opnd_mapping()","set_write_addr()","shape_too_complex?()","shift_stack()","side_exit()","size()","sp_opnd()","stack_opnd()","stack_pop()","stack_push()","stack_push_local()","stack_push_mapping()","stack_push_self()","static_symbol?()","static_symbol?()","stub()","sub()","symbol?()","test()","to_i()","to_i()","to_i()","to_i()","to_s()","to_s()","to_value()","to_value()","upgrade_opnd_type()","verify_ctx()","with_class_name()","with_stack_size()","with_write_addr()","write()","write_addr()","write_bytes()","write_label()","xor()"],"longSearchIndex":["rubyvm","rubyvm::rjit","rubyvm::rjit::assembler","rubyvm::rjit::assembler::label","rubyvm::rjit::assembler::modrm","rubyvm::rjit::assembler::rel32","rubyvm::rjit::block","rubyvm::rjit::branchstub","rubyvm::rjit::branchtarget","rubyvm::rjit::byteptr","rubyvm::rjit::cpointer","rubyvm::rjit::cpointer::bitfield","rubyvm::rjit::cpointer::bool","rubyvm::rjit::cpointer::immediate","rubyvm::rjit::cpointer::pointer","rubyvm::rjit::cpointer::struct","rubyvm::rjit::cpointer::union","rubyvm::rjit::ctype","rubyvm::rjit::ctype::bitfield","rubyvm::rjit::ctype::bool","rubyvm::rjit::ctype::immediate","rubyvm::rjit::ctype::pointer","rubyvm::rjit::ctype::struct","rubyvm::rjit::ctype::union","rubyvm::rjit::codeblock","rubyvm::rjit::compiler","rubyvm::rjit::context","rubyvm::rjit::dwordptr","rubyvm::rjit::entrystub","rubyvm::rjit::exitcompiler","rubyvm::rjit::insncompiler","rubyvm::rjit::invariants","rubyvm::rjit::jitstate","rubyvm::rjit::operandmatcher","rubyvm::rjit::type","rubyvm::rjit::typediff","rubyvm::rjit::cpointer::bitfield#*()","rubyvm::rjit::cpointer::bool#*()","rubyvm::rjit::cpointer::immediate#*()","rubyvm::rjit::cpointer::pointer#*()","rubyvm::rjit::cpointer::immediate#+()","rubyvm::rjit::cpointer::pointer#+()","rubyvm::rjit::cpointer::union#+()","rubyvm::rjit::cpointer::struct#-()","rubyvm::rjit::cpointer::union#-()","rubyvm::rjit::cpointer::immediate#[]()","rubyvm::rjit::cpointer::pointer#[]()","rubyvm::rjit::cpointer::struct#[]()","rubyvm::rjit::cpointer::bool::[]=()","rubyvm::rjit::cpointer::immediate#[]=()","rubyvm::rjit::cpointer::pointer#[]=()","rubyvm::rjit::cpointer::struct#[]=()","rubyvm::rjit::assembler#add()","rubyvm::rjit::compiler#add_block()","rubyvm::rjit::assembler#and()","rubyvm::rjit::assembler#assemble()","rubyvm::rjit::compiler#assert()","rubyvm::rjit::context#assert()","rubyvm::rjit::insncompiler#assert()","rubyvm::rjit::compiler#assert_compatible()","rubyvm::rjit::insncompiler#assert_equal()","rubyvm::rjit::invariants::assume_bop_not_redefined()","rubyvm::rjit::invariants::assume_method_basic_definition()","rubyvm::rjit::invariants::assume_method_lookup_stable()","rubyvm::rjit::invariants::assume_stable_constant_names()","rubyvm::rjit::jitstate#at_current_insn?()","rubyvm::rjit::assembler#block()","rubyvm::rjit::codeblock#bold()","rubyvm::rjit::compiler#branch_stub_hit()","rubyvm::rjit::insncompiler#build_calling()","rubyvm::rjit::insncompiler#builtin_function()","rubyvm::rjit::insncompiler#c_method_tracing_currently_enabled?()","rubyvm::rjit::assembler#call()","rubyvm::rjit::context#clear_local_types()","rubyvm::rjit::assembler#cmove()","rubyvm::rjit::assembler#cmovg()","rubyvm::rjit::assembler#cmovge()","rubyvm::rjit::assembler#cmovl()","rubyvm::rjit::assembler#cmovle()","rubyvm::rjit::assembler#cmovne()","rubyvm::rjit::assembler#cmovnz()","rubyvm::rjit::assembler#cmovz()","rubyvm::rjit::assembler#cmp()","rubyvm::rjit::codeblock#colorize()","rubyvm::rjit::assembler#comment()","rubyvm::rjit::compiler#compile()","rubyvm::rjit::compiler#compile_block()","rubyvm::rjit::exitcompiler#compile_branch_stub()","rubyvm::rjit::compiler#compile_entry_chain_guard()","rubyvm::rjit::exitcompiler#compile_entry_exit()","rubyvm::rjit::exitcompiler#compile_entry_stub()","rubyvm::rjit::exitcompiler#compile_full_cfunc_return()","rubyvm::rjit::exitcompiler#compile_leave_exit()","rubyvm::rjit::compiler#compile_prologue()","rubyvm::rjit::exitcompiler#compile_side_exit()","rubyvm::rjit::exitcompiler#count_insn_exit()","rubyvm::rjit::insncompiler#counted_exit()","rubyvm::rjit::compiler::decode_insn()","rubyvm::rjit::insncompiler#def_iseq_ptr()","rubyvm::rjit::insncompiler#defer_compilation()","rubyvm::rjit::cpointer::bitfield::define()","rubyvm::rjit::cpointer::immediate::define()","rubyvm::rjit::cpointer::pointer::define()","rubyvm::rjit::cpointer::struct::define()","rubyvm::rjit::cpointer::union::define()","rubyvm::rjit::cpointer::pointer#dest_addr()","rubyvm::rjit::context#diff()","rubyvm::rjit::codeblock#dump_disasm()","rubyvm::rjit::dump_trace_exits()","rubyvm::rjit::context#dup()","rubyvm::rjit::insncompiler#dynamic_symbol?()","rubyvm::rjit::assembler#encode_mod_rm()","rubyvm::rjit::invariants::ensure_block_entry_exit()","rubyvm::rjit::compiler#entry_stub_hit()","rubyvm::rjit::jitstate#ep_at_level()","rubyvm::rjit::exit_traces()","rubyvm::rjit::operandmatcher#extended_reg?()","rubyvm::rjit::ctype::immediate::find()","rubyvm::rjit::compiler#find_block()","rubyvm::rjit::insncompiler#fixnum?()","rubyvm::rjit::type::fixnum?()","rubyvm::rjit::insncompiler#flonum?()","rubyvm::rjit::type::flonum?()","rubyvm::rjit::format_number()","rubyvm::rjit::type::from()","rubyvm::rjit::insncompiler#full_cfunc_return()","rubyvm::rjit::context#get_local_type()","rubyvm::rjit::context#get_opnd_mapping()","rubyvm::rjit::context#get_opnd_type()","rubyvm::rjit::insncompiler#guard_block_arg()","rubyvm::rjit::insncompiler#handle_opt_send_shift_stack()","rubyvm::rjit::assembler#imm32()","rubyvm::rjit::operandmatcher#imm32?()","rubyvm::rjit::assembler#imm64()","rubyvm::rjit::operandmatcher#imm64?()","rubyvm::rjit::assembler#imm8()","rubyvm::rjit::operandmatcher#imm8?()","rubyvm::rjit::assembler#imm_bytes()","rubyvm::rjit::codeblock#include?()","rubyvm::rjit::assembler#incr_counter()","rubyvm::rjit::compiler#incr_counter()","rubyvm::rjit::invariants::initialize()","rubyvm::rjit::assembler#insn()","rubyvm::rjit::jitstate#insn()","rubyvm::rjit::invariants::invalidate_all()","rubyvm::rjit::compiler#invalidate_block()","rubyvm::rjit::compiler#invalidate_blocks()","rubyvm::rjit::compiler#iseq_lineno()","rubyvm::rjit::exitcompiler#iseq_lineno()","rubyvm::rjit::assembler#jbe()","rubyvm::rjit::assembler#je()","rubyvm::rjit::insncompiler#jit_array_len()","rubyvm::rjit::insncompiler#jit_array_ptr()","rubyvm::rjit::insncompiler#jit_call_alias()","rubyvm::rjit::insncompiler#jit_call_attrset()","rubyvm::rjit::insncompiler#jit_call_bmethod()","rubyvm::rjit::insncompiler#jit_call_cfunc()","rubyvm::rjit::insncompiler#jit_call_general()","rubyvm::rjit::insncompiler#jit_call_iseq()","rubyvm::rjit::insncompiler#jit_call_ivar()","rubyvm::rjit::insncompiler#jit_call_method()","rubyvm::rjit::insncompiler#jit_call_method_each_type()","rubyvm::rjit::insncompiler#jit_call_opt_call()","rubyvm::rjit::insncompiler#jit_call_opt_send()","rubyvm::rjit::insncompiler#jit_call_opt_struct_aref()","rubyvm::rjit::insncompiler#jit_call_optimized()","rubyvm::rjit::insncompiler#jit_call_symbol()","rubyvm::rjit::insncompiler#jit_caller_setup_arg()","rubyvm::rjit::insncompiler#jit_direct_jump()","rubyvm::rjit::insncompiler#jit_get_ep()","rubyvm::rjit::insncompiler#jit_get_lep()","rubyvm::rjit::insncompiler#jit_getivar()","rubyvm::rjit::insncompiler#jit_leaf_builtin_func()","rubyvm::rjit::insncompiler#jit_protected_callee_ancestry_guard()","rubyvm::rjit::insncompiler#jit_push_frame()","rubyvm::rjit::insncompiler#jit_search_method()","rubyvm::rjit::insncompiler#jit_write_iv()","rubyvm::rjit::assembler#jl()","rubyvm::rjit::assembler#jmp()","rubyvm::rjit::assembler#jne()","rubyvm::rjit::assembler#jnz()","rubyvm::rjit::assembler#jo()","rubyvm::rjit::assembler#jz()","rubyvm::rjit::assembler#lea()","rubyvm::rjit::compiler#leave_exit()","rubyvm::rjit::compiler#limit_block_versions()","rubyvm::rjit::compiler#list_blocks()","rubyvm::rjit::assembler#mov()","rubyvm::rjit::insncompiler#move_rest_args_to_stack()","rubyvm::rjit::assembler::new()","rubyvm::rjit::block::new()","rubyvm::rjit::cpointer::bitfield::new()","rubyvm::rjit::cpointer::immediate::new()","rubyvm::rjit::cpointer::pointer::new()","rubyvm::rjit::cpointer::struct::new()","rubyvm::rjit::cpointer::union::new()","rubyvm::rjit::ctype::bitfield::new()","rubyvm::rjit::ctype::bool::new()","rubyvm::rjit::ctype::immediate::new()","rubyvm::rjit::ctype::pointer::new()","rubyvm::rjit::ctype::struct::new()","rubyvm::rjit::ctype::union::new()","rubyvm::rjit::codeblock::new()","rubyvm::rjit::compiler::new()","rubyvm::rjit::context::new()","rubyvm::rjit::exitcompiler::new()","rubyvm::rjit::jitstate::new()","rubyvm::rjit::assembler#new_label()","rubyvm::rjit::invariants::on_cme_invalidate()","rubyvm::rjit::invariants::on_constant_ic_update()","rubyvm::rjit::invariants::on_constant_state_changed()","rubyvm::rjit::invariants::on_tracing_invalidate_all()","rubyvm::rjit::invariants::on_update_references()","rubyvm::rjit::jitstate#operand()","rubyvm::rjit::assembler#or()","rubyvm::rjit::ctype::immediate::parse()","rubyvm::rjit::exitcompiler#pc_to_insn()","rubyvm::rjit::jitstate#peek_at_block_handler()","rubyvm::rjit::jitstate#peek_at_local()","rubyvm::rjit::jitstate#peek_at_self()","rubyvm::rjit::jitstate#peek_at_stack()","rubyvm::rjit::assembler#pop()","rubyvm::rjit::assembler#pos_marker()","rubyvm::rjit::print_counters()","rubyvm::rjit::print_exit_counts()","rubyvm::rjit::print_stats()","rubyvm::rjit::assembler#push()","rubyvm::rjit::insncompiler#push_splat_args()","rubyvm::rjit::operandmatcher#r32?()","rubyvm::rjit::operandmatcher#r64?()","rubyvm::rjit::invariants::record_global_inval_patch()","rubyvm::rjit::assembler#reg_code()","rubyvm::rjit::operandmatcher#reg_code_extended()","rubyvm::rjit::assembler#rel32()","rubyvm::rjit::compiler#remove_block()","rubyvm::rjit::assembler#resolve_labels()","rubyvm::rjit::assembler#resolve_rel32()","rubyvm::rjit::assembler#ret()","rubyvm::rjit::compiler#rjit_blocks()","rubyvm::rjit::runtime_stats()","rubyvm::rjit::assembler#sar()","rubyvm::rjit::exitcompiler#save_pc_and_sp()","rubyvm::rjit::assembler#set_code_addrs()","rubyvm::rjit::context#set_local_type()","rubyvm::rjit::context#set_opnd_mapping()","rubyvm::rjit::codeblock#set_write_addr()","rubyvm::rjit::insncompiler#shape_too_complex?()","rubyvm::rjit::context#shift_stack()","rubyvm::rjit::insncompiler#side_exit()","rubyvm::rjit::assembler#size()","rubyvm::rjit::context#sp_opnd()","rubyvm::rjit::context#stack_opnd()","rubyvm::rjit::context#stack_pop()","rubyvm::rjit::context#stack_push()","rubyvm::rjit::context#stack_push_local()","rubyvm::rjit::context#stack_push_mapping()","rubyvm::rjit::context#stack_push_self()","rubyvm::rjit::insncompiler#static_symbol?()","rubyvm::rjit::type::static_symbol?()","rubyvm::rjit::assembler#stub()","rubyvm::rjit::assembler#sub()","rubyvm::rjit::insncompiler#symbol?()","rubyvm::rjit::assembler#test()","rubyvm::rjit::cpointer::immediate#to_i()","rubyvm::rjit::cpointer::pointer#to_i()","rubyvm::rjit::cpointer::struct#to_i()","rubyvm::rjit::cpointer::union#to_i()","rubyvm::rjit::cpointer::immediate#to_s()","rubyvm::rjit::cpointer::struct#to_s()","rubyvm::rjit::exitcompiler#to_value()","rubyvm::rjit::insncompiler#to_value()","rubyvm::rjit::context#upgrade_opnd_type()","rubyvm::rjit::compiler#verify_ctx()","rubyvm::rjit::cpointer::with_class_name()","rubyvm::rjit::context#with_stack_size()","rubyvm::rjit::codeblock#with_write_addr()","rubyvm::rjit::codeblock#write()","rubyvm::rjit::codeblock#write_addr()","rubyvm::rjit::assembler#write_bytes()","rubyvm::rjit::assembler#write_label()","rubyvm::rjit::assembler#xor()"],"info":[["RubyVM","","RubyVM.html","",""],["RubyVM::RJIT","","RubyVM/RJIT.html","",""],["RubyVM::RJIT::Assembler","","RubyVM/RJIT/Assembler.html","","<p>cdrdv2.intel.com/v1/dl/getContent/671110 Mostly an x86_64 assembler, but this also has some stuff that …\n"],["RubyVM::RJIT::Assembler::Label","","RubyVM/RJIT/Assembler/Label.html","","<p>rel8 jumps are made with labels\n"],["RubyVM::RJIT::Assembler::ModRM","","RubyVM/RJIT/Assembler/ModRM.html","","<p>A set of ModR/M values encoded on #insn\n"],["RubyVM::RJIT::Assembler::Rel32","","RubyVM/RJIT/Assembler/Rel32.html","","<p>rel32 is inserted as [Rel32, Rel32Pad..] and converted on #resolve_rel32\n"],["RubyVM::RJIT::Block","","RubyVM/RJIT/Block.html","",""],["RubyVM::RJIT::BranchStub","","RubyVM/RJIT/BranchStub.html","",""],["RubyVM::RJIT::BranchTarget","","RubyVM/RJIT/BranchTarget.html","",""],["RubyVM::RJIT::BytePtr","","RubyVM/RJIT/BytePtr.html","","<p>8-bit memory access\n"],["RubyVM::RJIT::CPointer","","RubyVM/RJIT/CPointer.html","","<p>Every class under this namespace is a pointer. Even if the type is immediate, it shouldn’t be dereferenced …\n"],["RubyVM::RJIT::CPointer::BitField","","RubyVM/RJIT/CPointer/BitField.html","",""],["RubyVM::RJIT::CPointer::Bool","","RubyVM/RJIT/CPointer/Bool.html","","<p>-Fiddle::TYPE_CHAR Immediate with special handling of true/false\n"],["RubyVM::RJIT::CPointer::Immediate","","RubyVM/RJIT/CPointer/Immediate.html","",""],["RubyVM::RJIT::CPointer::Pointer","","RubyVM/RJIT/CPointer/Pointer.html","",""],["RubyVM::RJIT::CPointer::Struct","","RubyVM/RJIT/CPointer/Struct.html","","<p>Note: We’d like to avoid alphabetic method names to avoid a conflict with member methods. to_i and …\n"],["RubyVM::RJIT::CPointer::Union","","RubyVM/RJIT/CPointer/Union.html","","<p>Note: We’d like to avoid alphabetic method names to avoid a conflict with member methods. to_i is …\n"],["RubyVM::RJIT::CType","","RubyVM/RJIT/CType.html","",""],["RubyVM::RJIT::CType::BitField","","RubyVM/RJIT/CType/BitField.html","",""],["RubyVM::RJIT::CType::Bool","","RubyVM/RJIT/CType/Bool.html","",""],["RubyVM::RJIT::CType::Immediate","","RubyVM/RJIT/CType/Immediate.html","",""],["RubyVM::RJIT::CType::Pointer","","RubyVM/RJIT/CType/Pointer.html","",""],["RubyVM::RJIT::CType::Struct","","RubyVM/RJIT/CType/Struct.html","",""],["RubyVM::RJIT::CType::Union","","RubyVM/RJIT/CType/Union.html","",""],["RubyVM::RJIT::CodeBlock","","RubyVM/RJIT/CodeBlock.html","",""],["RubyVM::RJIT::Compiler","","RubyVM/RJIT/Compiler.html","",""],["RubyVM::RJIT::Context","","RubyVM/RJIT/Context.html","",""],["RubyVM::RJIT::DwordPtr","","RubyVM/RJIT/DwordPtr.html","","<p>32-bit memory access\n"],["RubyVM::RJIT::EntryStub","","RubyVM/RJIT/EntryStub.html","",""],["RubyVM::RJIT::ExitCompiler","","RubyVM/RJIT/ExitCompiler.html","",""],["RubyVM::RJIT::InsnCompiler","","RubyVM/RJIT/InsnCompiler.html","",""],["RubyVM::RJIT::Invariants","","RubyVM/RJIT/Invariants.html","",""],["RubyVM::RJIT::JITState","","RubyVM/RJIT/JITState.html","",""],["RubyVM::RJIT::OperandMatcher","","RubyVM/RJIT/OperandMatcher.html","",""],["RubyVM::RJIT::Type","","RubyVM/RJIT/Type.html","","<p>This returns an appropriate Type based on a known value\n"],["RubyVM::RJIT::TypeDiff","","RubyVM/RJIT/TypeDiff.html","",""],["*","RubyVM::RJIT::CPointer::BitField","RubyVM/RJIT/CPointer/BitField.html#method-i-2A","()","<p>Dereference\n"],["*","RubyVM::RJIT::CPointer::Bool","RubyVM/RJIT/CPointer/Bool.html#method-i-2A","()",""],["*","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-2A","()","<p>Dereference\n"],["*","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-2A","()","<p>Dereference\n"],["+","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-2B","(index)","<p>Move addr to addess this pointer like an array\n"],["+","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-2B","(index)","<p>Move addr to addess this pointer like an array\n"],["+","RubyVM::RJIT::CPointer::Union","RubyVM/RJIT/CPointer/Union.html#method-i-2B","(index)","<p>Move addr to access this pointer like an array\n"],["-","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-i-2D","(struct)","<p>Pointer diff\n"],["-","RubyVM::RJIT::CPointer::Union","RubyVM/RJIT/CPointer/Union.html#method-i-2D","(union)","<p>Pointer diff\n"],["[]","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-5B-5D","(index)","<p>Array access\n"],["[]","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-5B-5D","(index)","<p>Array access\n"],["[]","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-i-5B-5D","(member)","<p>Primitive API that does no automatic dereference TODO: remove this? @param member [Symbol]\n"],["[]=","RubyVM::RJIT::CPointer::Bool","RubyVM/RJIT/CPointer/Bool.html#method-c-5B-5D-3D","(addr, value)",""],["[]=","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-5B-5D-3D","(index, value)","<p>Array set\n"],["[]=","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-5B-5D-3D","(index, value)","<p>Array set @param index [Integer] @param value [Integer, RubyVM::RJIT::CPointer::Struct] an address itself …\n"],["[]=","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-i-5B-5D-3D","(member, value)","<p>@param member [Symbol] @param value [Object]\n"],["add","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-add","(dst, src)","<p>Instructions\n"],["add_block","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-add_block","(iseq, block)","<p>@param [RubyVM::RJIT::Block] block\n"],["and","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-and","(dst, src)",""],["assemble","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-assemble","(addr)",""],["assert","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-assert","(cond)",""],["assert","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-assert","(cond)",""],["assert","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-assert","(cond)",""],["assert_compatible","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-assert_compatible","(actual_type, ctx_type)",""],["assert_equal","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-assert_equal","(left, right)",""],["assume_bop_not_redefined","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-assume_bop_not_redefined","(jit, klass, op)","<p>@param jit [RubyVM::RJIT::JITState] @param klass [Integer] @param op [Integer]\n"],["assume_method_basic_definition","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-assume_method_basic_definition","(jit, klass, mid)","<p>@param jit [RubyVM::RJIT::JITState]\n"],["assume_method_lookup_stable","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-assume_method_lookup_stable","(jit, cme)","<p>@param jit [RubyVM::RJIT::JITState]\n"],["assume_stable_constant_names","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-assume_stable_constant_names","(jit, idlist)",""],["at_current_insn?","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-at_current_insn-3F","()",""],["block","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-block","(block)","<p>Mark the starting address of a block\n"],["bold","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-bold","(text)",""],["branch_stub_hit","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-branch_stub_hit","(branch_stub, cfp, target0_p)","<p>Compile a branch stub. @param branch_stub [RubyVM::RJIT::BranchStub] @param cfp ‘RubyVM::RJIT::CPointer::Struct_rb_control_frame_t` …\n"],["build_calling","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-build_calling","(ci:, block_handler:)",""],["builtin_function","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-builtin_function","(iseq)","<p>Return a builtin function if a given iseq consists of only that builtin function\n"],["c_method_tracing_currently_enabled?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-c_method_tracing_currently_enabled-3F","()",""],["call","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-call","(dst)",""],["clear_local_types","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-clear_local_types","()","<p>Erase local variable type information eg: because of a call we can’t track\n"],["cmove","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmove","(dst, src)",""],["cmovg","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovg","(dst, src)",""],["cmovge","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovge","(dst, src)",""],["cmovl","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovl","(dst, src)",""],["cmovle","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovle","(dst, src)",""],["cmovne","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovne","(dst, src)",""],["cmovnz","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovnz","(dst, src)",""],["cmovz","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmovz","(dst, src)",""],["cmp","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-cmp","(left, right)",""],["colorize","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-colorize","(text, bold: false, color:)",""],["comment","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-comment","(message)",""],["compile","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-compile","(iseq, cfp)","<p>Compile an ISEQ from its entry point. @param iseq ‘RubyVM::RJIT::CPointer::Struct_rb_iseq_t` @param cfp …\n"],["compile_block","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-compile_block","(asm, jit:, pc:, ctx: Context.new)","<p>@param asm [RubyVM::RJIT::Assembler] @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] …\n"],["compile_branch_stub","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_branch_stub","(ctx, asm, branch_stub, target0_p)","<p>@param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] @param branch_stub [RubyVM::RJIT::BranchStub] …\n"],["compile_entry_chain_guard","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-compile_entry_chain_guard","(asm, iseq, pc)",""],["compile_entry_exit","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_entry_exit","(pc, ctx, asm, cause:)","<p>Used for invalidating a block on entry. @param pc [Integer] @param asm [RubyVM::RJIT::Assembler]\n"],["compile_entry_stub","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_entry_stub","(asm, entry_stub)","<p>@param asm [RubyVM::RJIT::Assembler] @param entry_stub [RubyVM::RJIT::EntryStub]\n"],["compile_full_cfunc_return","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_full_cfunc_return","(asm)","<p>Fire cfunc events on invalidation by TracePoint @param asm [RubyVM::RJIT::Assembler]\n"],["compile_leave_exit","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_leave_exit","(asm)","<p>Set to cfp-&gt;jit_return by default for leave insn @param asm [RubyVM::RJIT::Assembler]\n"],["compile_prologue","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-compile_prologue","(asm, iseq, pc)","<p>Callee-saved: rbx, rsp, rbp, r12, r13, r14, r15 Caller-saved: rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11 …\n"],["compile_side_exit","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-compile_side_exit","(pc, ctx, asm)","<p>@param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["count_insn_exit","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-count_insn_exit","(pc, asm)","<p>@param pc [Integer] @param asm [RubyVM::RJIT::Assembler]\n"],["counted_exit","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-counted_exit","(side_exit, name)",""],["decode_insn","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-c-decode_insn","(encoded)",""],["def_iseq_ptr","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-def_iseq_ptr","(cme_def)",""],["defer_compilation","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-defer_compilation","(jit, ctx, asm)","<p>@param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["define","RubyVM::RJIT::CPointer::BitField","RubyVM/RJIT/CPointer/BitField.html#method-c-define","(width, offset)","<p>@param width [Integer] @param offset [Integer]\n"],["define","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-c-define","(fiddle_type)","<p>@param fiddle_type [Integer] Fiddle::TYPE_*\n"],["define","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-c-define","(block)",""],["define","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-c-define","(size, members)","<p>@param size [Integer] @param members [Hash{ Symbol =&gt; [Integer, RubyVM::RJIT::CType::*] }]\n"],["define","RubyVM::RJIT::CPointer::Union","RubyVM/RJIT/CPointer/Union.html#method-c-define","(sizeof, members)","<p>@param sizeof [Integer] @param members [Hash{ Symbol =&gt; RubyVM::RJIT::CType::* }]\n"],["dest_addr","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-dest_addr","()",""],["diff","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-diff","(dst)","<p>Compute a difference score for two context objects\n"],["dump_disasm","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-dump_disasm","(from, to, io: STDOUT, color: true, test: false)",""],["dump_trace_exits","RubyVM::RJIT","RubyVM/RJIT.html#method-c-dump_trace_exits","()","<p>–yjit-trace-exits at_exit\n"],["dup","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-dup","()","<p>Deep dup by default for safety\n"],["dynamic_symbol?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-dynamic_symbol-3F","(obj)",""],["encode_mod_rm","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-encode_mod_rm","(mod:, reg: 0, rm: 0)","<p>Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte\n\n<pre>7  6  5  4  3  2  1  0</pre>\n<p><code>--</code>–<code>--</code>–<code>--</code>–<code>--</code>–+ | Mod …\n"],["ensure_block_entry_exit","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-ensure_block_entry_exit","(jit, cause:)","<p>@param jit [RubyVM::RJIT::JITState] @param block [RubyVM::RJIT::Block]\n"],["entry_stub_hit","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-entry_stub_hit","(entry_stub, cfp)","<p>Compile an entry. @param entry [RubyVM::RJIT::EntryStub]\n"],["ep_at_level","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-ep_at_level","(cfp, level:)",""],["exit_traces","RubyVM::RJIT","RubyVM/RJIT.html#method-c-exit_traces","()","<p>Convert rb_rjit_raw_samples and rb_rjit_line_samples into a StackProf format.\n"],["extended_reg?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-extended_reg-3F","(reg)",""],["find","RubyVM::RJIT::CType::Immediate","RubyVM/RJIT/CType/Immediate.html#method-c-find","(size, signed)",""],["find_block","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-find_block","(iseq, pc, ctx)","<p>@param [Integer] pc @param [RubyVM::RJIT::Context] ctx @return [RubyVM::RJIT::Block,NilClass]\n"],["fixnum?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-fixnum-3F","(obj)",""],["fixnum?","RubyVM::RJIT::Type","RubyVM/RJIT/Type.html#method-c-fixnum-3F","(obj)",""],["flonum?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-flonum-3F","(obj)",""],["flonum?","RubyVM::RJIT::Type","RubyVM/RJIT/Type.html#method-c-flonum-3F","(obj)",""],["format_number","RubyVM::RJIT","RubyVM/RJIT.html#method-c-format_number","(pad, number)","<p>Format large numbers with comma separators for readability\n"],["from","RubyVM::RJIT::Type","RubyVM/RJIT/Type.html#method-c-from","(val)",""],["full_cfunc_return","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-full_cfunc_return","()",""],["get_local_type","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-get_local_type","(idx)","<p>Get the currently tracked type for a local variable\n"],["get_opnd_mapping","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-get_opnd_mapping","(opnd)","<p>Get both the type and mapping (where the value originates) of an operand. This is can be used with stack_push_mapping …\n"],["get_opnd_type","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-get_opnd_type","(opnd)","<p>Get the type of an instruction operand\n"],["guard_block_arg","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-guard_block_arg","(jit, ctx, asm, calling)","<p>vm_caller_setup_arg_block: Handle VM_CALL_ARGS_BLOCKARG cases. @param jit [RubyVM::RJIT::JITState] @param …\n"],["handle_opt_send_shift_stack","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-handle_opt_send_shift_stack","(asm, argc, ctx, send_shift:)","<p>vm_call_opt_send (lazy part) @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["imm32","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-imm32","(imm)","<p>id: 4 bytes\n"],["imm32?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-imm32-3F","(imm)",""],["imm64","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-imm64","(imm)","<p>io: 8 bytes\n"],["imm64?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-imm64-3F","(imm)",""],["imm8","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-imm8","(imm)","<p>ib: 1 byte\n"],["imm8?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-imm8-3F","(imm)",""],["imm_bytes","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-imm_bytes","(imm, num_bytes)",""],["include?","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-include-3F","(addr)",""],["incr_counter","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-incr_counter","(name)",""],["incr_counter","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-incr_counter","(name)",""],["initialize","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-initialize","(cb, ocb, compiler, exit_compiler)","<p>Called by RubyVM::RJIT::Compiler to lazily initialize this @param cb [CodeBlock] @param ocb [CodeBlock] …\n"],["insn","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-insn","(prefix: 0, opcode:, rd: nil, mod_rm: nil, disp: nil, imm: nil)",""],["insn","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-insn","()",""],["invalidate_all","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-invalidate_all","()",""],["invalidate_block","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-invalidate_block","(block)",""],["invalidate_blocks","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-invalidate_blocks","(iseq, pc)","<p>@param iseq ‘RubyVM::RJIT::CPointer::Struct_rb_iseq_t` @param pc [Integer]\n"],["iseq_lineno","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-iseq_lineno","(iseq, pc)",""],["iseq_lineno","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-iseq_lineno","(iseq, pc)",""],["jbe","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jbe","(dst)",""],["je","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-je","(dst)",""],["jit_array_len","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_array_len","(asm, array_reg, len_reg)","<p>Generate RARRAY_LEN. For array_opnd, use Opnd::Reg to reduce memory access, and use Opnd::Mem to save …\n"],["jit_array_ptr","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_array_ptr","(asm, array_reg, ary_opnd)","<p>Generate RARRAY_CONST_PTR (part of RARRAY_AREF)\n"],["jit_call_alias","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_alias","(jit, ctx, asm, calling, cme, comptime_recv, recv_opnd, known_recv_class)","<p>vm_call_alias @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_attrset","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_attrset","(jit, ctx, asm, cme, calling, comptime_recv, recv_opnd)","<p>vm_call_attrset @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_bmethod","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_bmethod","(jit, ctx, asm, calling, cme, comptime_recv, recv_opnd, known_recv_class)","<p>vm_call_bmethod @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_cfunc","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_cfunc","(jit, ctx, asm, cme, calling, known_recv_class: nil)","<p>vm_call_cfunc @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_general","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_general","(jit, ctx, asm, mid, calling, cme, known_recv_class)","<p>vm_call_general @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_iseq","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_iseq","(jit, ctx, asm, cme, calling, iseq, frame_type: nil, prev_ep: nil)","<p>vm_call_iseq_setup @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm …\n"],["jit_call_ivar","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_ivar","(jit, ctx, asm, cme, calling, comptime_recv, recv_opnd)","<p>vm_call_ivar (+ part of vm_call_method_each_type) @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] …\n"],["jit_call_method","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_method","(jit, ctx, asm, mid, calling, cme, known_recv_class)","<p>vm_call_method @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_method_each_type","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_method_each_type","(jit, ctx, asm, calling, cme, comptime_recv, recv_opnd, known_recv_class)","<p>vm_call_method_each_type @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param …\n"],["jit_call_opt_call","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_opt_call","(jit, ctx, asm, cme, flags, argc, block_handler, known_recv_class, send_shift:)","<p>vm_call_opt_call @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_opt_send","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_opt_send","(jit, ctx, asm, cme, calling, known_recv_class)","<p>vm_call_opt_send @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_opt_struct_aref","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_opt_struct_aref","(jit, ctx, asm, cme, flags, argc, block_handler, known_recv_class, send_shift:)","<p>vm_call_opt_struct_aref @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param …\n"],["jit_call_optimized","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_optimized","(jit, ctx, asm, cme, calling, known_recv_class)","<p>vm_call_optimized @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_call_symbol","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_call_symbol","(jit, ctx, asm, cme, calling, known_recv_class, flags)","<p>vm_call_symbol @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_caller_setup_arg","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_caller_setup_arg","(jit, ctx, asm, flags)","<p>CALLER_SETUP_ARG: Return CantCompile if not supported @param jit [RubyVM::RJIT::JITState] @param ctx …\n"],["jit_direct_jump","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_direct_jump","(iseq, pc, ctx, asm, comment: 'jit_direct_jump')",""],["jit_get_ep","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_get_ep","(asm, level, reg:)","<p>vm_get_ep @param asm [RubyVM::RJIT::Assembler]\n"],["jit_get_lep","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_get_lep","(jit, asm, reg:)","<p>GET_LEP @param jit [RubyVM::RJIT::JITState] @param asm [RubyVM::RJIT::Assembler]\n"],["jit_getivar","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_getivar","(jit, ctx, asm, comptime_obj, ivar_id, obj_opnd, obj_yarv_opnd)","<p>vm_getivar @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_leaf_builtin_func","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_leaf_builtin_func","(jit, ctx, asm, flags, iseq)",""],["jit_protected_callee_ancestry_guard","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_protected_callee_ancestry_guard","(asm, cme, side_exit)","<p>Generate ancestry guard for protected callee. Calls to protected callees only go through when self.is_a …\n"],["jit_push_frame","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_push_frame","(jit, ctx, asm, cme, flags, argc, frame_type, block_handler, iseq: nil, local_size: 0, stack_max: 0, prev_ep: nil, doing_kw_call: nil)","<p>vm_push_frame\n<p>Frame structure: | args | locals | cme/cref | block_handler/prev EP | frame type (EP here) …\n"],["jit_search_method","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_search_method","(jit, ctx, asm, mid, calling)","<p>vm_search_method @param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["jit_write_iv","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-jit_write_iv","(asm, comptime_receiver, recv_reg, temp_reg, ivar_index, set_value, needs_extension)",""],["jl","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jl","(dst)",""],["jmp","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jmp","(dst)",""],["jne","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jne","(dst)",""],["jnz","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jnz","(dst)",""],["jo","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jo","(dst)",""],["jz","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-jz","(dst)",""],["lea","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-lea","(dst, src)",""],["leave_exit","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-leave_exit","()",""],["limit_block_versions","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-limit_block_versions","(iseq, pc, ctx)","<p>Produce a generic context when the block version limit is hit for the block\n"],["list_blocks","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-list_blocks","(iseq, pc)",""],["mov","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-mov","(dst, src)",""],["move_rest_args_to_stack","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-move_rest_args_to_stack","(array, num_args, jit, ctx, asm)","<p>Pushes arguments from an array to the stack. Differs from push splat because the array can have items …\n"],["new","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-c-new","()",""],["new","RubyVM::RJIT::Block","RubyVM/RJIT/Block.html#method-c-new","(incoming: [], invalidated: false, **)",""],["new","RubyVM::RJIT::CPointer::BitField","RubyVM/RJIT/CPointer/BitField.html#method-c-new","(addr, width, offset)","<p>@param addr [Integer] @param width [Integer] @param offset [Integer]\n"],["new","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-c-new","(addr, size, pack)","<p>@param addr [Integer] @param size [Integer] @param pack [String]\n"],["new","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-c-new","(addr, type)","<p>@param addr [Integer] @param type [Class] RubyVM::RJIT::CType::*\n"],["new","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-c-new","(addr, sizeof, members)","<p>@param name [String] @param sizeof [Integer] @param members [Hash{ Symbol =&gt; [RubyVM::RJIT::CType::*, …\n"],["new","RubyVM::RJIT::CPointer::Union","RubyVM/RJIT/CPointer/Union.html#method-c-new","(addr, sizeof, members)","<p>@param _name [String] To be used when it starts defining a union pointer class @param sizeof [Integer] …\n"],["new","RubyVM::RJIT::CType::BitField","RubyVM/RJIT/CType/BitField.html#method-c-new","(width, offset)","<p>@param width [Integer] @param offset [Integer]\n"],["new","RubyVM::RJIT::CType::Bool","RubyVM/RJIT/CType/Bool.html#method-c-new","()",""],["new","RubyVM::RJIT::CType::Immediate","RubyVM/RJIT/CType/Immediate.html#method-c-new","(fiddle_type)","<p>@param fiddle_type [Integer]\n"],["new","RubyVM::RJIT::CType::Pointer","RubyVM/RJIT/CType/Pointer.html#method-c-new","(&block)","<p>This takes a block to avoid “stack level too deep” on a cyclic reference @param block [Proc] …\n"],["new","RubyVM::RJIT::CType::Struct","RubyVM/RJIT/CType/Struct.html#method-c-new","(name, sizeof, **members)","<p>@param name [String] @param members [Hash{ Symbol =&gt; [Integer, RubyVM::RJIT::CType::*] }]\n"],["new","RubyVM::RJIT::CType::Union","RubyVM/RJIT/CType/Union.html#method-c-new","(name, sizeof, **members)","<p>@param name [String] @param members [Hash{ Symbol =&gt; RubyVM::RJIT::CType::* }]\n"],["new","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-c-new","(mem_block:, mem_size:, outlined: false)","<p>@param mem_block [Integer] JIT buffer address @param mem_size  [Integer] JIT buffer size @param outliend …\n"],["new","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-c-new","()",""],["new","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-c-new","( stack_size: 0, sp_offset: 0, chain_depth: 0, local_types: [Type::Unknown] * MAX_LOCAL_TYPES, temp_types: [Type::Unknown] * MAX_TEMP_TYPES, self_type: Type::Unknown, temp_mapping: [MapToStack] * MAX_TEMP_TYPES )",""],["new","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-c-new","(= freeze)",""],["new","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-c-new","(side_exit_for_pc: {}, record_boundary_patch_point: false, **)",""],["new_label","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-new_label","(name)",""],["on_cme_invalidate","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-on_cme_invalidate","(cme)",""],["on_constant_ic_update","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-on_constant_ic_update","(iseq, ic, insn_idx)",""],["on_constant_state_changed","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-on_constant_state_changed","(id)",""],["on_tracing_invalidate_all","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-on_tracing_invalidate_all","()",""],["on_update_references","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-on_update_references","()",""],["operand","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-operand","(index, signed: false, ruby: false)",""],["or","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-or","(dst, src)",""],["parse","RubyVM::RJIT::CType::Immediate","RubyVM/RJIT/CType/Immediate.html#method-c-parse","(ctype)","<p>@param type [String]\n"],["pc_to_insn","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-pc_to_insn","(pc)",""],["peek_at_block_handler","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-peek_at_block_handler","(level)",""],["peek_at_local","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-peek_at_local","(n)",""],["peek_at_self","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-peek_at_self","()",""],["peek_at_stack","RubyVM::RJIT::JITState","RubyVM/RJIT/JITState.html#method-i-peek_at_stack","(depth_from_top)",""],["pop","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-pop","(dst)",""],["pos_marker","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-pos_marker","(&block)",""],["print_counters","RubyVM::RJIT","RubyVM/RJIT.html#method-c-print_counters","(stats, prefix:, prompt:)",""],["print_exit_counts","RubyVM::RJIT","RubyVM/RJIT.html#method-c-print_exit_counts","(stats, how_many: 20, padding: 2)",""],["print_stats","RubyVM::RJIT","RubyVM/RJIT.html#method-c-print_stats","()","<p>–yjit-stats at_exit\n"],["push","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-push","(src)",""],["push_splat_args","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-push_splat_args","(required_args, jit, ctx, asm)","<p>vm_caller_setup_arg_splat (+ CALLER_SETUP_ARG): Pushes arguments from an array to the stack that are …\n"],["r32?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-r32-3F","(reg)",""],["r64?","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-r64-3F","(reg)",""],["record_global_inval_patch","RubyVM::RJIT::Invariants","RubyVM/RJIT/Invariants.html#method-c-record_global_inval_patch","(asm, target)","<p>@param asm [RubyVM::RJIT::Assembler]\n"],["reg_code","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-reg_code","(reg)",""],["reg_code_extended","RubyVM::RJIT::OperandMatcher","RubyVM/RJIT/OperandMatcher.html#method-i-reg_code_extended","(reg)",""],["rel32","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-rel32","(addr)",""],["remove_block","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-remove_block","(iseq, block)","<p>@param [RubyVM::RJIT::Block] block\n"],["resolve_labels","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-resolve_labels","()",""],["resolve_rel32","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-resolve_rel32","(write_addr)",""],["ret","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-ret","()",""],["rjit_blocks","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-rjit_blocks","(iseq)",""],["runtime_stats","RubyVM::RJIT","RubyVM/RJIT.html#method-c-runtime_stats","()",""],["sar","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-sar","(dst, src)",""],["save_pc_and_sp","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-save_pc_and_sp","(pc, ctx, asm, reset_sp_offset: true)","<p>@param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context] @param asm [RubyVM::RJIT::Assembler] …\n"],["set_code_addrs","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-set_code_addrs","(write_addr)",""],["set_local_type","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-set_local_type","(local_idx, local_type)","<p>Set the type of a local variable\n"],["set_opnd_mapping","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-set_opnd_mapping","(opnd, mapping_opnd_type)","<p>Overwrite both the type and mapping of a stack operand.\n"],["set_write_addr","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-set_write_addr","(addr)",""],["shape_too_complex?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-shape_too_complex-3F","(obj)",""],["shift_stack","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-shift_stack","(argc)",""],["side_exit","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-side_exit","(jit, ctx)","<p>@param jit [RubyVM::RJIT::JITState] @param ctx [RubyVM::RJIT::Context]\n"],["size","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-size","()",""],["sp_opnd","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-sp_opnd","(offset_bytes = 0)",""],["stack_opnd","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_opnd","(depth_from_top)",""],["stack_pop","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_pop","(n = 1)","<p>Pop N values off the stack Return a pointer to the stack top before the pop operation\n"],["stack_push","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_push","(val_type)","<p>Push one new value on the temp stack Return a pointer to the new stack top\n"],["stack_push_local","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_push_local","(local_idx)","<p>Push a local variable on the stack\n"],["stack_push_mapping","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_push_mapping","(mapping_temp_type)","<p>Push one new value on the temp stack with an explicit mapping Return a pointer to the new stack top\n"],["stack_push_self","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-stack_push_self","()","<p>Push the self value on the stack\n"],["static_symbol?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-static_symbol-3F","(obj)",""],["static_symbol?","RubyVM::RJIT::Type","RubyVM/RJIT/Type.html#method-c-static_symbol-3F","(obj)",""],["stub","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-stub","(stub)","<p>Mark the starting/ending addresses of a stub\n"],["sub","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-sub","(dst, src)",""],["symbol?","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-symbol-3F","(obj)",""],["test","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-test","(left, right)",""],["to_i","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-to_i","()","<p>Get a raw address\n"],["to_i","RubyVM::RJIT::CPointer::Pointer","RubyVM/RJIT/CPointer/Pointer.html#method-i-to_i","()","<p>Get a raw address\n"],["to_i","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-i-to_i","()","<p>Get a raw address\n"],["to_i","RubyVM::RJIT::CPointer::Union","RubyVM/RJIT/CPointer/Union.html#method-i-to_i","()","<p>Get a raw address\n"],["to_s","RubyVM::RJIT::CPointer::Immediate","RubyVM/RJIT/CPointer/Immediate.html#method-i-to_s","()","<p>Serialized address for generated code. Used for embedding things like body-&gt;iseq_encoded.\n"],["to_s","RubyVM::RJIT::CPointer::Struct","RubyVM/RJIT/CPointer/Struct.html#method-i-to_s","()","<p>Serialized address for generated code\n"],["to_value","RubyVM::RJIT::ExitCompiler","RubyVM/RJIT/ExitCompiler.html#method-i-to_value","(obj)",""],["to_value","RubyVM::RJIT::InsnCompiler","RubyVM/RJIT/InsnCompiler.html#method-i-to_value","(obj)",""],["upgrade_opnd_type","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-upgrade_opnd_type","(opnd, opnd_type)","<p>Upgrade (or “learn”) the type of an instruction operand This value must be compatible and at …\n"],["verify_ctx","RubyVM::RJIT::Compiler","RubyVM/RJIT/Compiler.html#method-i-verify_ctx","(jit, ctx)","<p>Verify the ctx’s types and mappings against the compile-time stack, self, and locals. @param jit …\n"],["with_class_name","RubyVM::RJIT::CPointer","RubyVM/RJIT/CPointer.html#method-c-with_class_name","(prefix, name, cache: false, &block)","<p>Give a name to a dynamic CPointer class to see it on inspect\n"],["with_stack_size","RubyVM::RJIT::Context","RubyVM/RJIT/Context.html#method-i-with_stack_size","(stack_size)","<p>Create a new Context instance with a given stack_size and sp_offset adjusted accordingly. This is useful …\n"],["with_write_addr","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-with_write_addr","(addr)",""],["write","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-write","(asm)","<p>@param asm [RubyVM::RJIT::Assembler]\n"],["write_addr","RubyVM::RJIT::CodeBlock","RubyVM/RJIT/CodeBlock.html#method-i-write_addr","()",""],["write_bytes","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-write_bytes","(addr)",""],["write_label","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-write_label","(label)","<p>@param [RubyVM::RJIT::Assembler::Label] label\n"],["xor","RubyVM::RJIT::Assembler","RubyVM/RJIT/Assembler.html#method-i-xor","(dst, src)",""]]}}