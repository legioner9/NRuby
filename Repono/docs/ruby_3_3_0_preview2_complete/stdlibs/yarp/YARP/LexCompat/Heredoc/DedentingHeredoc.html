<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<title>class YARP::LexCompat::Heredoc::DedentingHeredoc - yarp: Ruby Standard Library Documentation</title>


<script src="../../../js/navigation.js" defer></script>
<script src="../../../js/search.js" defer></script>
<script src="../../../js/search_index.js" defer></script>
<script src="../../../js/searcher.js" defer></script>
<script src="../../../js/darkfish.js" defer></script>

<script src="../../../js/jquery-3.2.0.min.js"></script>

<script src="../../../js/vue.min.js"></script>
<script src="../../../js/js.cookie.min.js"></script>

<link href="../../../css/fonts.css" rel="stylesheet">
<link id='rdoccss' href="../../../css/rdoc.css" rel="stylesheet">
<link href="../../../css/carbon17.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../";
  var index_rel_prefix = "../../../";
  var darkModeCsseHref = "../../../css/rdoc-dm.css"
  var defaultModeCssHref = "../../../css/rdoc.css"
  // var cssDarkmode = Cookies.get('darkmode');
  
  if( Cookies.get("darkmode") == "true") {
	$('#rdoccss').attr("href", darkModeCsseHref);
}

//  https://cssdeck.com/blog/simple-jquery-stylesheet-switcher/

document.write('<style type="text/css">body{display:none}</style>');

</script>


</head>
<body id="top" role="document" class="class">
  <!-- this is class.html -->

  <div id='actionbar' >
    <div class='wrapper mdiv'>
      <ul class='grids g0'></ul>
    </div> 
    <!-- VERSION HEADER for 3.3.0.preview2 NOT FOUND -->
  </div> <!-- end action bar -->

  <div class='wrapper hdiv'>

    


    <nav id='vapp' role="navigation">
    <div id="project-navigation">
      <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2><a href="../../../index.html" rel="home">Home</a></h2>

  <div id="table-of-contents-navigation"  >
    <a href="../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

      <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

    </div>


    

    <button id='toggleThing' @click="toggleNav()" >Show/hide navigation</button>
    <div :class="isOpen ? 'block' : 'hidden' " id='toggleMe'>
      <div id="class-metadata">
        
        
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="../../../Object.html">Object</a>
</div>

        
        
        
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    <li ><a href="#method-i-to_a">#to_a</a>
  </ul>
</div>

      </div>
     </div>
    </nav>


    <div id='extraz'><div class='adzbox-index'  >
      
     </div>         
    </div>

    <main role="main" aria-labelledby="class-YARP::LexCompat::Heredoc::DedentingHeredoc">
    <h1 id="class-YARP::LexCompat::Heredoc::DedentingHeredoc" class="class">
      class YARP::LexCompat::Heredoc::DedentingHeredoc
    </h1>

    <section class="description">
    
<p>Heredocs that are dedenting heredocs are a little more complicated. Ripper outputs on_ignored_sp tokens for the whitespace that is being removed from the output. <a href="../../../YARP.html"><code>YARP</code></a> only modifies the node itself and keeps the token the same. This simplifies <a href="../../../YARP.html"><code>YARP</code></a>, but makes comparing against Ripper much harder because there is a length mismatch.</p>

<p>Fortunately, we already have to pull out the heredoc tokens in order to insert them into the stream in the correct order. As such, we can do some extra manipulation on the tokens to make them match Ripperâ€™s output by mirroring the dedent logic that Ripper uses.</p>

    </section>

      <section id="5Buntitled-5D" class="documentation-section">


      <section class="constants-list">
      <header>
      <h3>Constants</h3>
      </header>
      <dl>
          <dt id="TAB_WIDTH">TAB_WIDTH
          <dd>
        </dl>
        </section>

        <section class="attribute-method-details" class="method-section">
        <header>
        <h3>Attributes</h3>
        </header>

          <div id="attribute-i-dedent" class="method-detail">
            <div class="method-heading attribute-method-heading">
              <span class="method-name">dedent</span><span
                class="attribute-access-type">[R]</span>
            </div>

            <div class="method-description">
              
              </div>
            </div>
          <div id="attribute-i-dedent_next" class="method-detail">
            <div class="method-heading attribute-method-heading">
              <span class="method-name">dedent_next</span><span
                class="attribute-access-type">[R]</span>
            </div>

            <div class="method-description">
              
              </div>
            </div>
          <div id="attribute-i-embexpr_balance" class="method-detail">
            <div class="method-heading attribute-method-heading">
              <span class="method-name">embexpr_balance</span><span
                class="attribute-access-type">[R]</span>
            </div>

            <div class="method-description">
              
              </div>
            </div>
          <div id="attribute-i-tokens" class="method-detail">
            <div class="method-heading attribute-method-heading">
              <span class="method-name">tokens</span><span
                class="attribute-access-type">[R]</span>
            </div>

            <div class="method-description">
              
              </div>
            </div>
            </section>


                <section id="public-class-5Buntitled-5D-method-details" class="method-section">
                <header>
                <h3>Public Class Methods</h3>
                </header>

                  <div id="method-c-new" class="method-detail ">
                            <div class="method-heading">
                              <span class="method-name">new</span><span
                                class="method-args">()</span>
                              <span class="method-click-advice">click to toggle source</span>
                            </div>

                            <div class="method-description">
                              

                              <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File yarp/lex_compat.rb, line 354</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>
  <span class="ruby-ivar">@tokens</span> = []
  <span class="ruby-ivar">@dedent_next</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-ivar">@dedent</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@embexpr_balance</span> = <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
                              </div>
                            </div>


                          </div>

                          </section>

                <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
                <header>
                <h3>Public Instance Methods</h3>
                </header>

                  <div id="method-i-3C-3C" class="method-detail ">
                            <div class="method-heading">
                              <span class="method-name">&lt;&lt;</span><span
                                class="method-args">(token)</span>
                              <span class="method-click-advice">click to toggle source</span>
                            </div>

                            <div class="method-description">
                              <p>As tokens are coming in, we track the minimum amount of common leading whitespace on plain string content tokens. This allows us to later remove that amount of whitespace from the beginning of each line.</p>

                              <div class="method-source-code" id="3C-3C-source">
            <pre><span class="ruby-comment"># File yarp/lex_compat.rb, line 364</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">&lt;&lt;</span>(<span class="ruby-identifier">token</span>)
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_beg</span>, <span class="ruby-value">:on_heredoc_beg</span>
    <span class="ruby-ivar">@embexpr_balance</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_end</span>, <span class="ruby-value">:on_heredoc_end</span>
    <span class="ruby-ivar">@embexpr_balance</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">when</span> <span class="ruby-value">:on_tstring_content</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
      <span class="ruby-identifier">token</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/(?&lt;=\n)/</span>).<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
        <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">strip</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&quot;\n&quot;</span>)
        <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">dedent_next</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)

        <span class="ruby-identifier">leading</span> = <span class="ruby-identifier">line</span>[<span class="ruby-regexp">/\A(\s*)\n?/</span>, <span class="ruby-value">1</span>]
        <span class="ruby-identifier">next_dedent</span> = <span class="ruby-value">0</span>

        <span class="ruby-identifier">leading</span>.<span class="ruby-identifier">each_char</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">char</span><span class="ruby-operator">|</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">char</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\t&quot;</span>
            <span class="ruby-identifier">next_dedent</span> = <span class="ruby-identifier">next_dedent</span> <span class="ruby-operator">-</span> (<span class="ruby-identifier">next_dedent</span> <span class="ruby-operator">%</span> <span class="ruby-constant">TAB_WIDTH</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">TAB_WIDTH</span>
          <span class="ruby-keyword">else</span>
            <span class="ruby-identifier">next_dedent</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-ivar">@dedent</span> = [<span class="ruby-identifier">dedent</span>, <span class="ruby-identifier">next_dedent</span>].<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">min</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-ivar">@dedent_next</span> = <span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span> <span class="ruby-operator">==</span> <span class="ruby-value">:on_tstring_content</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-identifier">tokens</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
<span class="ruby-keyword">end</span></pre>
                              </div>
                            </div>


                          </div>

                  <div id="method-i-to_a" class="method-detail ">
                            <div class="method-heading">
                              <span class="method-name">to_a</span><span
                                class="method-args">()</span>
                              <span class="method-click-advice">click to toggle source</span>
                            </div>

                            <div class="method-description">
                              

                              <div class="method-source-code" id="to_a-source">
            <pre><span class="ruby-comment"># File yarp/lex_compat.rb, line 396</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_a</span>
  <span class="ruby-comment"># If every line in the heredoc is blank, we still need to split up the</span>
  <span class="ruby-comment"># string content token into multiple tokens.</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">dedent</span>.<span class="ruby-identifier">nil?</span>
    <span class="ruby-identifier">results</span> = []
    <span class="ruby-identifier">embexpr_balance</span> = <span class="ruby-value">0</span>

    <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">token</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_beg</span>, <span class="ruby-value">:on_heredoc_beg</span>
        <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_end</span>, <span class="ruby-value">:on_heredoc_end</span>
        <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
      <span class="ruby-keyword">when</span> <span class="ruby-value">:on_tstring_content</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
          <span class="ruby-identifier">lineno</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span>]
          <span class="ruby-identifier">column</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>][<span class="ruby-value">1</span>]

          <span class="ruby-identifier">token</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/(?&lt;=\n)/</span>).<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span>, <span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-value">0</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
            <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Token</span>.<span class="ruby-identifier">new</span>([[<span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">column</span>], <span class="ruby-value">:on_tstring_content</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">token</span>.<span class="ruby-identifier">state</span>])
            <span class="ruby-identifier">lineno</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Otherwise, we&#39;re going to run through each token in the list and</span>
  <span class="ruby-comment"># insert on_ignored_sp tokens for the amount of dedent that we need to</span>
  <span class="ruby-comment"># perform. We also need to remove the dedent from the beginning of</span>
  <span class="ruby-comment"># each line of plain string content tokens.</span>
  <span class="ruby-identifier">results</span> = []
  <span class="ruby-identifier">dedent_next</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">embexpr_balance</span> = <span class="ruby-value">0</span>

  <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">token</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># Notice that the structure of this conditional largely matches the</span>
    <span class="ruby-comment"># whitespace calculation we performed above. This is because</span>
    <span class="ruby-comment"># checking if the subsequent token needs to be dedented is common to</span>
    <span class="ruby-comment"># both the dedent calculation and the ignored_sp insertion.</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_beg</span>
      <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:on_embexpr_end</span>
      <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
    <span class="ruby-keyword">when</span> <span class="ruby-value">:on_tstring_content</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
        <span class="ruby-comment"># Here we&#39;re going to split the string on newlines, but maintain</span>
        <span class="ruby-comment"># the newlines in the resulting array. We&#39;ll do that with a look</span>
        <span class="ruby-comment"># behind assertion.</span>
        <span class="ruby-identifier">splits</span> = <span class="ruby-identifier">token</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/(?&lt;=\n)/</span>)
        <span class="ruby-identifier">index</span> = <span class="ruby-value">0</span>

        <span class="ruby-keyword">while</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">splits</span>.<span class="ruby-identifier">length</span>
          <span class="ruby-identifier">line</span> = <span class="ruby-identifier">splits</span>[<span class="ruby-identifier">index</span>]
          <span class="ruby-identifier">lineno</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>][<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-identifier">index</span>
          <span class="ruby-identifier">column</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>][<span class="ruby-value">1</span>]

          <span class="ruby-comment"># Blank lines do not count toward common leading whitespace</span>
          <span class="ruby-comment"># calculation and do not need to be dedented.</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">dedent_next</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
            <span class="ruby-identifier">column</span> = <span class="ruby-value">0</span>
          <span class="ruby-keyword">end</span>

          <span class="ruby-comment"># If the dedent is 0 and we&#39;re not supposed to dedent the next</span>
          <span class="ruby-comment"># line or this line doesn&#39;t start with whitespace, then we</span>
          <span class="ruby-comment"># should concatenate the rest of the string to match ripper.</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">dedent</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">dedent_next</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">line</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-regexp">/\s/</span>))
            <span class="ruby-identifier">line</span> = <span class="ruby-identifier">splits</span>[<span class="ruby-identifier">index</span><span class="ruby-operator">..</span>].<span class="ruby-identifier">join</span>
            <span class="ruby-identifier">index</span> = <span class="ruby-identifier">splits</span>.<span class="ruby-identifier">length</span>
          <span class="ruby-keyword">end</span>

          <span class="ruby-comment"># If we are supposed to dedent this line or if this is not the</span>
          <span class="ruby-comment"># first line of the string and this line isn&#39;t entirely blank,</span>
          <span class="ruby-comment"># then we need to insert an on_ignored_sp token and remove the</span>
          <span class="ruby-comment"># dedent from the beginning of the line.</span>
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">dedent</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">dedent_next</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)
            <span class="ruby-identifier">deleting</span> = <span class="ruby-value">0</span>
            <span class="ruby-identifier">deleted_chars</span> = []

            <span class="ruby-comment"># Gather up all of the characters that we&#39;re going to</span>
            <span class="ruby-comment"># delete, stopping when you hit a character that would put</span>
            <span class="ruby-comment"># you over the dedent amount.</span>
            <span class="ruby-identifier">line</span>.<span class="ruby-identifier">each_char</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">char</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
              <span class="ruby-keyword">case</span> <span class="ruby-identifier">char</span>
              <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;\r&quot;</span>
                <span class="ruby-keyword">if</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">chars</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;\n&quot;</span>
                  <span class="ruby-keyword">break</span>
                <span class="ruby-keyword">end</span>
              <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;\n&quot;</span>
                <span class="ruby-keyword">break</span>
              <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;\t&quot;</span>
                <span class="ruby-identifier">deleting</span> = <span class="ruby-identifier">deleting</span> <span class="ruby-operator">-</span> (<span class="ruby-identifier">deleting</span> <span class="ruby-operator">%</span> <span class="ruby-constant">TAB_WIDTH</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">TAB_WIDTH</span>
              <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">deleting</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
              <span class="ruby-keyword">end</span>

              <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">deleting</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dedent</span>
              <span class="ruby-identifier">deleted_chars</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">char</span>
            <span class="ruby-keyword">end</span>

            <span class="ruby-comment"># If we have something to delete, then delete it from the</span>
            <span class="ruby-comment"># string and insert an on_ignored_sp token.</span>
            <span class="ruby-keyword">if</span> <span class="ruby-identifier">deleted_chars</span>.<span class="ruby-identifier">any?</span>
              <span class="ruby-identifier">ignored</span> = <span class="ruby-identifier">deleted_chars</span>.<span class="ruby-identifier">join</span>
              <span class="ruby-identifier">line</span>.<span class="ruby-identifier">delete_prefix!</span>(<span class="ruby-identifier">ignored</span>)

              <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Token</span>.<span class="ruby-identifier">new</span>([[<span class="ruby-identifier">lineno</span>, <span class="ruby-value">0</span>], <span class="ruby-value">:on_ignored_sp</span>, <span class="ruby-identifier">ignored</span>, <span class="ruby-identifier">token</span>[<span class="ruby-value">3</span>]])
              <span class="ruby-identifier">column</span> = <span class="ruby-identifier">ignored</span>.<span class="ruby-identifier">length</span>
            <span class="ruby-keyword">end</span>
          <span class="ruby-keyword">end</span>

          <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Token</span>.<span class="ruby-identifier">new</span>([[<span class="ruby-identifier">lineno</span>, <span class="ruby-identifier">column</span>], <span class="ruby-identifier">token</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">line</span>, <span class="ruby-identifier">token</span>[<span class="ruby-value">3</span>]]) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">line</span>.<span class="ruby-identifier">empty?</span>
          <span class="ruby-identifier">index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">results</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">token</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">dedent_next</span> =
      ((<span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span> <span class="ruby-operator">==</span> <span class="ruby-value">:on_tstring_content</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">token</span>.<span class="ruby-identifier">event</span> <span class="ruby-operator">==</span> <span class="ruby-value">:on_heredoc_end</span>)) <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">embexpr_balance</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">results</span>
<span class="ruby-keyword">end</span></pre>
                              </div>
                            </div>


                          </div>

                          </section>

              </section>
              </main>



            </div>  <!--  class='wrapper hdiv' -->


<footer id="validator-badges" role="contentinfo">
<p><a href="https://validator.w3.org/check/referer">Validate</a></p>
<p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.</p>
<p>Based on <a href="https://github.com/ged/darkfish/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.</p>

  
    <p><p><a href="https://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="https://jamesbritt.com">James Britt</a> and <a href="https://neurogami.com">Neurogami</a>.</p><p><a href="https://jamesbritt.bandcamp.com/">Maximum R+D</a>.  </p>
</p>
  
  </footer>

<script type="text/javascript">


  let ads  = $("#carbonads-container").children().detach();


  function swapMode() {
    var cookieName = 'darkmode';
    var cssDarkmode = Cookies.get(cookieName);
    console.log("***** swapMode! " + cssDarkmode + " *****");


    if (cssDarkmode == "true") {
      console.log("We have dark mode, set the css to light ...");
      $('#rdoccss').attr("href", defaultModeCssHref);
      $('#cssSelect').text("Dark mode");
      cssDarkmode = "false";
      console.log("swapMode! Now set cookie to " + cssDarkmode);
      Cookies.set(cookieName, cssDarkmode);

    } else {
      console.log("We not have dark mode, set the css to dark ...");
      $('#rdoccss').attr("href", darkModeCsseHref);
      $('#cssSelect').text("Light mode");
      cssDarkmode = "true";
      console.log("swapMode! Now set cookie to " + cssDarkmode);
      Cookies.set(cookieName, cssDarkmode);

    }

    console.log("  --------------- ");
  }


const vueCssApp = new Vue({
el: '#menubar',
data: {
isDark: false
},
methods: {
toggleClass: function(event){
this.isDark = !this.isDark;
}
}
})

const vueApp = new Vue({
el: '#vapp',
data: { 
isOpen: true
},

mounted() {
this.handleResize();
this.manage_mob_classes();
window.addEventListener('resize', this.handleResize)
//this.isOpen !=  (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
},
destroyed() {
window.removeEventListener('resize', this.handleResize)
},
created() {
//manage_mob_classes();
},

methods : {
isMobile() {
  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
},

  handleResize() {
    if (!this.isMobile()) {
      this.isOpen = window.innerWidth > 800;
    }
  },

  manage_mob_classes() {
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      $("nav").addClass("mob_nav");
      $("main").addClass("mob_main");
      $("#extraz").addClass("mob_extraz");
      $("#carbonads-container").addClass("mob_carbonads-container");
      this.isOpen  = false;
    } else {
      $("nav").removeClass("mob_nav") 
        $("main").removeClass("mob_main");
      $("#extraz").removeClass("mob_extraz");
      $("#carbonads-container").removeClass("mob_carbonads-container");
      this.isOpen  = true;
    }
  },

  toggleNav() {
    this.isOpen =! this.isOpen ;
    // alert("Toggle nav!");
    console.log("toggleNav() click: " + this.isOpen );
  }
}
})

$("#carbonads-container").append(ads);


$(function() {

    var darkmode = Cookies.get("darkmode");
    console.log("Document ready: " + darkmode);

    if ( darkmode  == "true" ) {
      $('#cssSelect').text("Light mode");
    } else {
      $('#cssSelect').text("Dark mode");
     }

    $('body').css('display','block');
    });

</script>

    
  </body> 
</html>

